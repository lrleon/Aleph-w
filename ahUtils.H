
/* Aleph-w

     / \  | | ___ _ __ | |__      __      __
    / _ \ | |/ _ \ '_ \| '_ \ ____\ \ /\ / / Data structures & Algorithms
   / ___ \| |  __/ |_) | | | |_____\ V  V /  version 1.9b
  /_/   \_\_|\___| .__/|_| |_|      \_/\_/   https://github.com/lrleon/Aleph-w
                 |_|

  This file is part of Aleph-w library

  Copyright (c) 2002-2018 Leandro Rabindranath Leon 

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/>.
*/
# ifndef AHUTILS_H
# define AHUTILS_H

# include <sys/stat.h>
//# include <stdlib.h>
# include <cstdlib>
# include <cassert>
# include <cmath>
# include <memory>
# include <limits>
# include <cxxabi.h>
# include <string>
# include <sstream>
# include <iostream>
# include <fstream>
# include <typeinfo>

# include <ahFunction.H>
//# include <ah-convert.H>
// # include <htlist.H>
// # include <tpl_array.H>

using namespace std;

namespace Aleph {


    /** Retorna un puntero a la mediana entre tres datos.

	Se retorna un puntero a efectos de ahorrar la copia y, muy
	especialmente, para emplear la igualdad por punteros.

	@ingroup fcts
     */
  template <class T, class Compare = Aleph::less<T>> inline
const T * median(const T & a, const T & b, const T & c, Compare & cmp)
{
  if (cmp(a, b))
    if (cmp(b, c))
      return &b;
    else if (cmp(a, c))
      return &c;
    else
      return &a;
  else if (cmp(a, c))
    return &a;
  else if (cmp(b, c))
    return &c;
  else
    return &b;
}


  /** Retorna <code>true</code> si n es par

     @ingroup fcts
   */
inline bool is_even(long n)
{
  return (n % 2) == 0;
}

  /** Retorna <code>true</code> si n es impar

     @ingroup fcts
   */
inline bool is_odd(long n)
{
  return not is_even(n);
}

  /** Convierte una nibla almaceneda en un <code>int</code> a un
      <code<>char/code>.

      @ingroup fcts
   */
inline char nibble_to_char(const int & i)
{
  assert(i >= 0 and i <= 15);

  const char ret = i < 10 ? i + '0' : i - 10 + 'A';

  assert((ret >= '0' and ret <= '9') or (ret >= 'A' and ret <= 'F'));

  return ret;
}

  /** Convierte una nibla almaceneda en un <code<>char/code> a un
      <code>int</code>.

      @ingroup fcts
   */
inline int char_to_nibble(const char & c)
{
  assert((c >= '0' and c <= '9') or (c >= 'A' and c <= 'F'));

  const int ret = c < 'A' ? c - '0' : c - 'A' + 10;

  assert(ret >= 0 and ret <= 15);

  return ret;
}

# define DERIVATE_ITERATOR(container_name,  base_it_name, it_name) \
  struct it_name : public base_it_name                             \
  {                                                                \
    it_name() { /* empty */ }                                      \
		                                                               \
    it_name(container_name & c) : base_it_name(c)                  \
      {                                                            \
        /* empty */                                                \
      }                                                            \
                                                                   \
    it_name(const it_name & it) : base_it_name(it)                 \
      {                                                            \
        /* empty */                                                \
      }                                                            \
                                                                   \
    it_name & operator = (const it_name & it)                      \
    {                                                              \
      return base_it_name::operator = (it);                        \
    }                                                              \
  };


/** Reajusta el tamaño de la pila sistema a new_size. Retorna true si
    tiene éxito; false de lo contrario

   @ingroup fcts
 */
extern bool resize_process_stack(size_t new_size);

inline size_t u_index(const size_t & i)
{
  return i >> 1; // divide i entre 2
}

inline size_t l_index(const size_t & i)
{
  return i << 1; // multiplica i por 2
}

/** 

    Taken from http://stackoverflow.com/questions/3638431/determine-if-an-int-is-a-power-of-2-or-not-in-a-single-line

    @ingroup utils
*/
inline bool is_power_of_2(unsigned long x) 
{
  return x && !(x & (x - 1UL));
}

/** Given a linker symbol name generated by a c++ compiler, this
  functions decodes it into a user level name.
  
  @ingroup fcts
 */
inline std::string demangle(const char* name)
{
  int status = -4; // some arbitrary value to eliminate the compiler warning
  // enable c++11 by passing the flag -std=c++11 to g++
  std::unique_ptr<char, void(*)(void*)> res
    { abi::__cxa_demangle(name, NULL, NULL, &status), std::free };
  return (status==0) ? res.get() : name ;
}

/** Given a pointer, it returns the class name 
  
  @ingroup fcts
 */
# define CLASSNAME_TO_STRING(class_ptr) demangle(typeid(*class_ptr).name())

/** Print a error message and aborts

   @ingroup fcts
 */
inline void error_msg(const string & msg)
{
  cout << msg << endl;
  abort();
}

/** Return `true` if it exists a file of `name`

   @ingroup fcts
 */
inline bool exists_file(const string & name)
{
  struct stat buffer;
  return (stat (name.c_str(), &buffer) == 0);
}

/** Return a string with R specification of a vector with `name` and
   data stored in container `c`

   @ingroup fcts
 */
template <class C>
inline std::string Rvector(const std::string & name, const C & c)
{
  std::ostringstream s;
  s << name << " <- c(";
  auto last_ptr = &c.get_last();
  for (auto it = c.get_it(); it.has_curr(); it.next())
    {
      auto & v = it.get_curr();
      s << v;
      if (&v != last_ptr)
	s << ", ";
    }
  s << ")";

  return s.str();
}

template <class C>
inline std::string Rvector(const C & c)
{
  std::ostringstream s;
  s << c.get_first() << " <- c(";
  auto last_ptr = &c.get_last();
  for (auto it = c.get_it(1); it.has_curr(); it.next())
    {
      auto & v = it.get_curr();
      s << v;
      if (&v != last_ptr)
	s << ", ";
    }
  s << ")";

  return s.str();
}

/** Basic linear interpolation

   This function receives a pair of points in a plane plus a x point
   and computes the value of f(x) through linear interpolation

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2`

  @ingroup fcts
 */
inline
double interpolate(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 > x1 and x <= x2 and x >= x1);
  return y1 + (y2 - y1)*(x - x1)/(x2 - x1);
}

/** Basic linear extrapolation

   This function receives a pair of points in a plane plus a x point
   less than `x1` and `x2` and computes the value of f(x) 

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2` and `x` must be less
   than `x1`

   @ingroup fcts
 */
inline
double extrapolate_left(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 > x1 and x < x1);
  return y1 - (y2 - y1)*(x1 - x)/(x2 - x1);
}

/** Return x^2
   @ingroup fcts
 */
inline double pow2(double x) { return x*x; }

/** Return x^3
   @ingroup fcts
 */
inline double pow3(double x) { return x*pow2(x); }

/** Basic linear extrapolation

   This function receives a pair of points in a plane plus a x point
   less than `x1` and `x2` and computes the value of f(x) 

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2` and `x` must be greater 
   than `x2`

   @ingroup fcts
 */
inline
double extrapolate_right(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 > x1 and x > x2);
  return y2 + (y2 - y1)*(x - x2)/(x2 - x1);
}

/** Return the next representable floating-point value to `val`

   @ingroup fcts
 */
inline double next_value(double val)
{
  return nextafter(val, numeric_limits<double>::max());
}

/** Return the previous representable floating-point value to `val`

    @ingroup fcts
 */
inline double prev_value(double val)
{
  return nextafter(val, numeric_limits<double>::min());
}

/** Return `true` if v1 is near of v2 by absolute difference e

    @ingroup fcts
 */
inline bool are_near(double v1, double v2, double e) { return fabs(v1 - v2) <= e; }

/** Generate and execute a R script from a string (containing the script)

    @param[in] scr string containing the script
    @param[in] file name of temporal file where the script will be saved

   @ingroup fcts
 */
inline
void execute_R_script(const string & scr, const string & file_name = "tmp.R")
{
  std::ofstream tmp(file_name);
  tmp << "#!/usr/bin/Rscript" << endl
      << endl
      << "X11()" << endl
      << scr << endl
      << "message(\"Press Return To Continue\")" << endl
      << "invisible(readLines(\"stdin\", n=1))" << endl;
  const string cmd = "Rscript " + file_name;
  system(cmd.c_str());
}

inline bool is_normal_number(double n)
{
  int status = fpclassify(n);
  return (status == FP_NORMAL or status == FP_ZERO) // and status != FP_NAN and
    // status != FP_INFINITE and status != FP_SUBNORMAL
    ;
}

}


# endif // AHUTILS_H

