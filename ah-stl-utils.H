
/* Aleph-w

     / \  | | ___ _ __ | |__      __      __
    / _ \ | |/ _ \ '_ \| '_ \ ____\ \ /\ / / Data structures & Algorithms
   / ___ \| |  __/ |_) | | | |_____\ V  V /  version 1.9b
  /_/   \_\_|\___| .__/|_| |_|      \_/\_/   https://github.com/lrleon/Aleph-w
                 |_|

  This file is part of Aleph-w library

  Copyright (c) 2002-2018 Leandro Rabindranath Leon 

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/>.
*/
# ifndef AH_STL_UTILS_H
# define AH_STL_UTILS_H

# include <list>
# include <vector>

# include <htlist.H>
# include <tpl_dynDlist.H>
# include <tpl_array.H>
# include <tpl_dynArray.H>
# include <tpl_dynSetTree.H>

template<class F, class...Ts, std::size_t...Is> inline
void for_each_in_tuple(const std::tuple<Ts...> & tuple,
                       F func, std::index_sequence<Is...>)
{
  using expander = int[];
  (void)expander { 0, ((void)func(std::get<Is>(tuple)), 0)... };
}

template<class F, class...Ts> inline
void for_each_in_tuple(const std::tuple<Ts...> & tuple, F func)
{
  for_each_in_tuple(tuple, func, std::make_index_sequence<sizeof...(Ts)>());
}

template <typename T> inline
DynList<T> vector_to_DynList(const std::vector<T> & v)
{
  DynList<T> ret;
  for (auto & item : v)
    ret.append(item);

  return ret;
}

template <typename T> inline
DynList<T> to_DynList(const std::vector<T> & v)
{
  return vector_to_DynList(v);
}

template <typename T> inline
Array<T> to_Array(const std::vector<T> & v)
{
  Array<T> ret;
  for (auto & item : v)
    ret.append(item);

  return ret;
}

template <typename C> inline
std::vector<typename C::Item_Type> to_vector(const C & c)
{
  std::vector<typename C::Item_Type> ret;
  c.for_each([&ret] (const auto & i) { ret.push_back(i); });
  return ret;
}

/* Boost Software License - Version 1.0 - August 17th, 2003 Permission
   is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation
   covered by this license (the "Software") to use, reproduce,
   display, distribute, execute, and transmit the Software, and to
   prepare derivative works of the Software, and to permit
   third-parties to whom the Software is furnished to do so, all
   subject to the following:

   The copyright notices in the Software and this entire statement,
   including the above license grant, this restriction and the
   following disclaimer, must be included in all copies of the
   Software, in whole or in part, and all derivative works of the
   Software, unless such copies or derivative works are solely in the
   form of machine-executable object code generated by a source
   language processor.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
   NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
   DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
   LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/

/// A type that represents a parameter pack of zero or more integers.
template<unsigned... Indexes>
struct index_tuple
{
  /// Generate an index_tuple with an additional element.
  template<unsigned N> using append = index_tuple<Indexes..., N>;
};

/// Unary metafunction that generates an index_tuple containing [0, Size)
template<unsigned Size>
struct make_index_tuple
{
  typedef typename make_index_tuple<Size-1>::type::template append<Size-1>
  type;
};

// Terminal case of the recursive metafunction.
template<> struct make_index_tuple<0u>
{
  typedef index_tuple<> type;
};

template<typename... Types>
using to_index_tuple = typename make_index_tuple<sizeof...(Types)>::type;

// Based on:
//   http://stackoverflow.com/questions/10604794/convert-stdtuple-to-stdarray-c11

template<class Container, typename T, typename... U, unsigned... I>
inline static Container
tuple_to_container(const std::tuple<T, U...> & t, index_tuple<I...>)
{
  return build_container<Container>(std::get<I>(t)...);
}

template<class Container, typename T, typename... U, unsigned... I>
inline Container tuple_to_container(const std::tuple<T, U...> & t)
{
  using IndexTuple = typename make_index_tuple<1 + sizeof...(U)>::type;
  return tuple_to_container<Container>(t, IndexTuple());
}

template<typename T, typename... U>
inline DynList<T> tuple_to_dynlist(const std::tuple<T, U...> & t)
{
  return tuple_to_container<DynList<T>>(t);
}

template<typename T, typename... U>
inline Array<T> tuple_to_array(const std::tuple<T, U...> & t)
{
  return tuple_to_container<Array<T>>(t);
}

template <typename StlContainer>
auto stl_container_to_dynList(const StlContainer & container)
{
  DynList<typename StlContainer::value_type> ret;
  for (const auto & item : container)
    ret.append(item);
  return ret;
}


# endif // AH_STL_UTILS_H
